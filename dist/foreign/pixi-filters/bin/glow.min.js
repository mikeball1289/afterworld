/*!
 * pixi-filters - v1.0.8
 * Compiled Mon, 24 Jul 2017 17:05:04 UTC
 *
 * pixi-filters is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
!function(r,o){"object"==typeof exports&&"undefined"!=typeof module?o(exports):"function"==typeof define&&define.amd?define(["exports"],o):o(r.__pixiFilters={})}(this,function(r){"use strict";if(void 0===PIXI.Filter)throw"PixiJS is required";var o="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void){\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}\r\n",t="varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nuniform float distance;\r\nuniform float outerStrength;\r\nuniform float innerStrength;\r\nuniform vec4 glowColor;\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nvec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\r\n\r\nvoid main(void) {\r\n    const float PI = 3.14159265358979323846264;\r\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\r\n    vec4 curColor;\r\n    float totalAlpha = 0.0;\r\n    float maxTotalAlpha = 0.0;\r\n    float cosAngle;\r\n    float sinAngle;\r\n    vec2 displaced;\r\n    for (float angle = 0.0; angle <= PI * 2.0; angle += %QUALITY_DIST%) {\r\n       cosAngle = cos(angle);\r\n       sinAngle = sin(angle);\r\n       for (float curDistance = 1.0; curDistance <= %DIST%; curDistance++) {\r\n           displaced.x = vTextureCoord.x + cosAngle * curDistance * px.x;\r\n           displaced.y = vTextureCoord.y + sinAngle * curDistance * px.y;\r\n           curColor = texture2D(uSampler, clamp(displaced, filterClamp.xy, filterClamp.zw));\r\n           totalAlpha += (distance - curDistance) * curColor.a;\r\n           maxTotalAlpha += (distance - curDistance);\r\n       }\r\n    }\r\n    maxTotalAlpha = max(maxTotalAlpha, 0.0001);\r\n\r\n    ownColor.a = max(ownColor.a, 0.0001);\r\n    ownColor.rgb = ownColor.rgb / ownColor.a;\r\n    float outerGlowAlpha = (totalAlpha / maxTotalAlpha)  * outerStrength * (1. - ownColor.a);\r\n    float innerGlowAlpha = ((maxTotalAlpha - totalAlpha) / maxTotalAlpha) * innerStrength * ownColor.a;\r\n    float resultAlpha = (ownColor.a + outerGlowAlpha);\r\n    gl_FragColor = vec4(mix(mix(ownColor.rgb, glowColor.rgb, innerGlowAlpha / ownColor.a), glowColor.rgb, outerGlowAlpha / resultAlpha) * resultAlpha, resultAlpha);\r\n}\r\n",n=function(r){function n(n,e,i,l,a){void 0===n&&(n=10),void 0===e&&(e=4),void 0===i&&(i=0),void 0===l&&(l=16777215),void 0===a&&(a=.1),r.call(this,o,t.replace(/%QUALITY_DIST%/gi,""+(1/a/n).toFixed(7)).replace(/%DIST%/gi,""+n.toFixed(7))),this.uniforms.glowColor=new Float32Array([0,0,0,1]),this.distance=n,this.color=l,this.outerStrength=e,this.innerStrength=i}r&&(n.__proto__=r),(n.prototype=Object.create(r&&r.prototype)).constructor=n;var e={color:{},distance:{},outerStrength:{},innerStrength:{}};return e.color.get=function(){return PIXI.utils.rgb2hex(this.uniforms.glowColor)},e.color.set=function(r){PIXI.utils.hex2rgb(r,this.uniforms.glowColor)},e.distance.get=function(){return this.uniforms.distance},e.distance.set=function(r){this.uniforms.distance=r},e.outerStrength.get=function(){return this.uniforms.outerStrength},e.outerStrength.set=function(r){this.uniforms.outerStrength=r},e.innerStrength.get=function(){return this.uniforms.innerStrength},e.innerStrength.set=function(r){this.uniforms.innerStrength=r},Object.defineProperties(n.prototype,e),n}(PIXI.Filter);r.GlowFilter=n,Object.defineProperty(r,"__esModule",{value:!0}),Object.assign(PIXI.filters,__pixiFilters)});
//# sourceMappingURL=glow.min.js.map
